import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import { GeneratorConfig, SwaggerParser } from "@ng-openapi/shared";
import { Project } from "ts-morph";
import { AdminGenerator } from "../src/lib/generators/admin/admin.generator";
import * as fs from 'fs';
import * as path from 'path';

// --- MOCKS ---
const originalFs = require('fs');
vi.mock('fs');

// Spec for testing individual Material components
const ultimateSpec = {
    openapi: '3.0.0',
    info: { title: 'Ultimate Test API', version: '1.0.0' },
    paths: {
        '/servers': {
            get: { tags: ['Servers'], responses: { '200': { description: 'OK' } } },
            post: { tags: ['Servers'], requestBody: { content: { 'application/json': { schema: { $ref: '#/components/schemas/CreateServer' } } } } }
        },
        '/servers/{id}': {
            get: { tags: ['Servers'], parameters: [{ name: 'id', in: 'path' }] },
            put: { tags: ['Servers'], parameters: [{ name: 'id', in: 'path' }] }
        }
    },
    components: {
        schemas: {
            CreateServer: {
                type: 'object',
                required: ['name', 'priority', 'status'],
                properties: {
                    name: { type: 'string', minLength: 3, maxLength: 50 },
                    notes: { type: 'string', format: 'textarea' },
                    priority: { type: 'string', enum: ['Low', 'Normal', 'High'] },
                    status: { type: 'string', enum: ['PENDING', 'ONLINE', 'OFFLINE', 'MAINTENANCE', 'DECOMMISSIONED'] },
                    isEnabled: { type: 'boolean' },
                    cpuUsage: { type: 'integer', minimum: 0, maximum: 100 },
                    tags: { type: 'array', items: { type: 'string' } },
                    backupDays: { type: 'array', items: { type: 'string', enum: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'] } },
                    launchDate: { type: 'string', format: 'date' }
                }
            }
        }
    }
};

// NEW: Spec for testing advanced features like readOnly and nested objects.
const advancedSpec = {
    openapi: '3.0.0',
    info: { title: 'Advanced Test API', version: '1.0.0' },
    paths: {
        '/projects': {
            post: { tags: ['Projects'], requestBody: { content: { 'application/json': { schema: { $ref: '#/components/schemas/CreateProject' } } } } }
        }
    },
    components: {
        schemas: {
            CreateProject: {
                type: 'object',
                required: ['projectName'],
                properties: {
                    id: { type: 'integer', readOnly: true, description: 'The project ID, generated by the server.' },
                    projectName: { type: 'string' },
                    contactPerson: { $ref: '#/components/schemas/ContactPerson' }
                }
            },
            ContactPerson: {
                type: 'object',
                required: ['name'],
                properties: {
                    name: { type: 'string' },
                    email: { type: 'string' }
                }
            }
        }
    }
};

// --- TEST SUITE ---
describe('AdminGenerator', () => {
    async function setupGenerator(spec: any, proj: Project, partialConfig: Partial<GeneratorConfig> = {}) {
        const config: GeneratorConfig = { input: 'mock-spec.json', output: '/output', options: { admin: true }, ...partialConfig };
        if (partialConfig.options) { config.options = { ...config.options, ...partialConfig.options }; }

        vi.spyOn(fs, 'readFileSync').mockImplementation((p: any) => {
            if (p.toString().endsWith('mock-spec.json')) return JSON.stringify(spec);
            if (p.toString().includes('.template')) {
                const templateName = path.basename(p);
                const actualPath = path.resolve(__dirname, `../src/lib/generators/admin/templates/${templateName}`);
                return originalFs.readFileSync(actualPath, 'utf8');
            } return '';
        });
        vi.spyOn(fs, 'existsSync').mockReturnValue(true);
        const parser = await SwaggerParser.create(config.input, config);
        return new AdminGenerator(parser, proj, config);
    }

    afterEach(() => { vi.restoreAllMocks(); });

    describe('Individual Component Generation', () => {
        let formComponentHtml: string;
        let formComponentTs: string;
        beforeEach(async () => {
            const project = new Project({ useInMemoryFileSystem: true });
            const generator = await setupGenerator(ultimateSpec, project, { options: { admin: { booleanType: 'slide-toggle' } as any } });
            await generator.generate('/output');
            formComponentHtml = project.getSourceFileOrThrow('/output/admin/servers/server-form/server-form.component.html').getFullText();
            formComponentTs = project.getSourceFileOrThrow('/output/admin/servers/server-form/server-form.component.ts').getFullText();
        });

        it("should generate a MatDatepicker from a string with date format", () => expect(formComponentHtml).toContain('mat-datepicker-toggle'));
        it("should generate a MatButtonToggleGroup from an array with an enum", () => expect(formComponentHtml).toContain('mat-button-toggle-group'));
        it("should generate a MatRadioGroup from an enum with 4 or fewer options", () => expect(formComponentHtml).toContain('mat-radio-group'));
        it("should generate a MatSelect from an enum with more than 4 options", () => expect(formComponentHtml).toContain('mat-select'));
        it("should generate MatSlideToggles from a boolean when configured", () => expect(formComponentHtml).toContain('mat-slide-toggle'));
        it("should generate a MatChipList from a string array", () => expect(formComponentHtml).toContain('mat-chip-grid'));
        it("should generate a MatSlider from an integer with min and max", () => expect(formComponentHtml).toContain('mat-slider'));
        it("should generate a textarea from a string with textarea format", () => expect(formComponentHtml).toContain('<textarea matInput'));
        it("should generate FormControls with validators", () => expect(formComponentTs).toContain('validators: [Validators.required, Validators.minLength(3), Validators.maxLength(50)]'));
    });

    // NEW SUITE FOR ADVANCED FEATURES
    describe('Advanced Schema Handling', () => {
        let formComponentHtml: string;
        let formComponentTs: string;
        beforeEach(async () => {
            const project = new Project({ useInMemoryFileSystem: true });
            const generator = await setupGenerator(advancedSpec, project);
            await generator.generate('/output');
            formComponentHtml = project.getSourceFileOrThrow('/output/admin/projects/project-form/project-form.component.html').getFullText();
            formComponentTs = project.getSourceFileOrThrow('/output/admin/projects/project-form/project-form.component.ts').getFullText();
        });

        it('should NOT generate form controls for readOnly properties', () => {
            expect(formComponentTs).not.toContain("'id': new FormControl");
            expect(formComponentHtml).not.toContain('formControlName="id"');
        });

        it('should generate a nested FormGroup for object properties', () => {
            const expectedTsStructure = `'contactPerson': new FormGroup({ 'name': new FormControl<CreateProject['contactPerson']['name']>("", { validators: [Validators.required], nonNullable: true }), 'email': new FormControl<CreateProject['contactPerson']['email'] | null>(null) })`;

            const normalizedActual = formComponentTs.replace(/\s/g, '');
            const normalizedExpected = expectedTsStructure.replace(/\s/g, '');

            expect(normalizedActual).toContain(normalizedExpected);
        });

        it('should generate HTML with formGroupName for nested objects', () => {
            expect(formComponentHtml).toContain('<mat-expansion-panel>');
            expect(formComponentHtml).toContain('formGroupName="contactPerson"');
            expect(formComponentHtml).toContain('formControlName="name"');
            expect(formComponentHtml).toContain('formControlName="email"');
        });
    });

    describe('Default Value Generation', () => {
        const defaultValueSpec = { openapi: '3.0.0', info: { title: 'Default Test API', version: '1.0' }, paths: { '/configs': { get: { tags: ['Configs'] }, post: { tags: ['Configs'], requestBody: { content: { 'application/json': { schema: { $ref: '#/components/schemas/CreateConfig' } } } } } } }, components: { schemas: { CreateConfig: { type: 'object', properties: { name: { type: 'string', default: 'Default Name' }, retries: { type: 'integer', default: 3 }, isActive: { type: 'boolean', default: true }, tags: { type: 'array', items: { type: 'string' }, default: ['initial', 'default'] }, description: { type: 'string' } } } } } };
        let formComponentTs: string;
        beforeEach(async () => {
            const project = new Project({ useInMemoryFileSystem: true });
            const generator = await setupGenerator(defaultValueSpec, project);
            await generator.generate('/output');
            formComponentTs = project.getSourceFileOrThrow('/output/admin/configs/config-form/config-form.component.ts').getFullText();
        });

        it('should use the default value from a string property', () => expect(formComponentTs).toContain(`'name': new FormControl<CreateConfig['name'] | null>("Default Name")`));
        it('should use the default value from a number property', () => expect(formComponentTs).toContain(`'retries': new FormControl<CreateConfig['retries'] | null>(3)`));
        it('should use the default value from a boolean property', () => expect(formComponentTs).toContain(`'isActive': new FormControl<CreateConfig['isActive'] | null>(true)`));
        it('should use the default value from an array property', () => expect(formComponentTs).toContain(`'tags': new FormControl<CreateConfig['tags'] | null>(["initial", "default"])`));
        it('should use null for a property without a default value', () => expect(formComponentTs).toContain(`'description': new FormControl<CreateConfig['description'] | null>(null)`));
    });
});
